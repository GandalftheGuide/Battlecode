package ProtoPlayer;

import java.util.ArrayList;

import battlecode.common.*;

public class Archon{
	public static RobotController rc = RobotPlayer.rc;
	public static ArrayList<RobotInfo> closeNeut = new ArrayList<RobotInfo>();
	public static ArrayList<RobotInfo> farNeut = new ArrayList<RobotInfo>();
	public static boolean neutInProx = true;
	public static boolean id;
	public static Direction stepping = Direction.NORTH;

	public static void setRun() throws GameActionException{


		if (rc.getRoundNum() == 0) {
			if (rc.getType() == RobotType.ARCHON) {
				rc.broadcastMessageSignal(7346, 0, 10000);

				Signal[] received = rc.emptySignalQueue();
				int numArchons = 0;
				for (Signal s : received) {
					if (s.getMessage() != null && s.getMessage()[0] == 7346) {
						numArchons++;
					}
				}
				if (numArchons == 0) {
					id = true;
				}else{id = false;} 
			}
		}


		else{
			Direction randD = Utility.randomDirection();
			if(id == true){
				shouldRun();
				if(rc.getRoundNum()<25 || rc.getRoundNum()%50 == 0)
				Utility.sendingInstructions();
				
				defense();
				
//				randD = Utility.randomDirection();
//				
//				if(Utility.isClear(randD)!=null){
//					randD=Utility.isClear(randD);
//					if(rc.isCoreReady()&& rc.canBuild(randD, RobotType.SOLDIER))
//						rc.build(randD, RobotType.SOLDIER);
//				}
			}
			else if(id == false){
				MapLocation archon = Utility.followingInstructions();
				if(archon==null)
					archon=rc.getLocation();
				
				Direction randomD = Utility.randomDirection();

				shouldRun();
				
				findResource();

				if(neutInProx){
					activeNeut();
				}

				if(rc.getRoundNum()< 90 && rc.getLocation().distanceSquaredTo(archon) > 24 && rc.isCoreReady()){
					Utility.advance(rc.getLocation().directionTo(archon), 1);

				}
				else if(rc.getRoundNum()< 90 && rc.getLocation().distanceSquaredTo(archon) < 24 && rc.isCoreReady()){
					Utility.advance(rc.getLocation().directionTo(archon).opposite(), 1);

				}
				else if(Utility.isClear(randD)!=null){
					randD = Utility.randomDirection();
					randD=Utility.isClear(randD);
					if(rc.isCoreReady()&& rc.canBuild(randD, RobotType.SOLDIER))
						rc.build(randD, RobotType.SOLDIER);
				}
			}
		}
	}

	public static void findResource() throws GameActionException {
		MapLocation [] parts = rc.sensePartLocations(1750);
		//RobotInfo[] neutral = 
		
		if(rc.isCoreReady() && parts.length>0){
			Utility.advance(rc.getLocation().directionTo(parts[0]),1);
		}
		
	}
	
	public static void defense() throws GameActionException{
		Direction randD = Utility.randomDirection();
		RobotInfo[] surround = rc.senseNearbyRobots(4);
		int numTurrets = 0;
		
		for(int i = 0; i< surround.length; i++){
			if(surround[i].type == RobotType.TURRET || surround[i].type == RobotType.TTM){
				numTurrets++;
			}
		}
		
		
		if(rc.getRoundNum()< 75){
			if(Utility.isClear(randD)!=null){
				randD=Utility.isClear(randD);
				if(rc.isCoreReady()&& rc.canBuild(randD, RobotType.SOLDIER))
					rc.build(randD, RobotType.SOLDIER);
			}
		}
		else if(numTurrets > 7){
			rc.broadcastMessageSignal(51 ,0 ,9);
		}
		else{
			stepping = Utility.isClear(stepping);
			if(Utility.isClear(stepping)!=null){
				if(rc.isCoreReady()&& rc.canBuild(stepping, RobotType.TURRET))
					rc.build(stepping, RobotType.TURRET);
			}
			stepping = stepping.rotateRight();
		}
		
	}

	public static void shouldRun() throws GameActionException{
		RobotInfo [] enemies = rc.senseHostileRobots(rc.getLocation(), 24);
		RobotInfo [] enemiesFar = rc.senseHostileRobots(rc.getLocation(), 50);


		if(enemies.length >=1 && rc.isCoreReady()){
			Utility.advance((rc.getLocation().directionTo(enemies[0].location)).opposite(), 1);
		}
		else if(enemiesFar.length > 6 && rc.isCoreReady()){
			Utility.advance((rc.getLocation().directionTo(enemiesFar[0].location)).opposite(), 1);
		}
	}

	public static void activeNeut() throws GameActionException{

		RobotInfo[] neutR = rc.senseNearbyRobots(25, Team.NEUTRAL);

		for(int i = 0; i<neutR.length; i++){
			if(rc.getLocation().distanceSquaredTo(neutR[i].location) < 3){
				closeNeut.add(neutR[i]);
			}
			if(rc.getLocation().distanceSquaredTo(neutR[i].location) >= 3){
				farNeut.add(neutR[i]);
			}
		}
		if((farNeut.isEmpty() && closeNeut.isEmpty()) || rc.getRoundNum() > 9){
			neutInProx = false;
		}

		if(closeNeut.size()>0){
			for(int i = 0; i<closeNeut.size(); i++){
				if(rc.isCoreReady()){
					rc.activate(closeNeut.remove(i).location);
				}
			}
		}else if(farNeut.size()>0){
			for(int i = 0; i<farNeut.size(); i++){
				if(rc.isCoreReady()){
					Utility.advance(rc.getLocation().directionTo(farNeut.get(i).location),1);
				}
			}
		}
	}

}
